{
  "version": 3,
  "sources": ["../src/index.ts", "../src/internal/index.ts", "../src/hooks/meta.ts", "../src/utils/global.ts", "../src/utils/tools.ts", "../src/utils/promise.ts", "../src/hooks/visible.ts", "../src/hooks/holder.ts", "../src/helper/render.ts", "../src/helper/define.ts", "../src/transform/index.ts", "../src/components/index.ts"],
  "sourcesContent": ["import type { App } from 'vue-demi'\r\nimport { context } from './internal'\r\n\r\nconst install = (app: App) => {\r\n  context.appContext = app._context\r\n}\r\nconst unoverlay = { install }\r\n\r\nexport type { ImperativeOverlay, RenderOptions } from './transform'\r\nexport type { OverlayOptions, OverlayMeta, InjectionHolder } from './hooks'\r\nexport { useOverlayMeta, useInjectHolder } from './hooks'\r\nexport { createOverlay, renderOverlay } from './transform'\r\nexport { UnifiedOverlayProvider } from './components'\r\nexport { install }\r\n\r\nexport default unoverlay\r\n", "import type { AppContext, InjectionKey } from 'vue-demi'\r\nimport type { OverlayMeta } from '../hooks'\r\n\r\nexport const context = {\r\n  appContext: null as null | AppContext,\r\n}\r\nexport const OverlayMetaKey: InjectionKey<OverlayMeta> = Symbol('__imperative_overlay_key')\r\n\r\nexport enum OverEvents {\r\n  Cancel = 'cancel',\r\n  Confirm = 'confirm',\r\n}\r\n", "import type { Ref } from 'vue-demi'\r\nimport { getCurrentInstance, inject, onMounted, provide, ref, watch } from 'vue-demi'\r\nimport { useVModel } from '@vueuse/core'\r\nimport { OverlayMetaKey } from '../internal'\r\nimport { delay, noop } from '../utils'\r\n\r\nexport interface OverlayOptions {\r\n  /** animation duration to avoid premature destruction of components */\r\n  animation?: number\r\n  /** whether to set visible to true immediately */\r\n  immediate?: boolean\r\n  /**\r\n   * v-model fields used by template\r\n   *\r\n   * @default 'visible'\r\n   */\r\n  model?: string\r\n\r\n  /**\r\n   * template use event name\r\n   */\r\n  event?: {\r\n    /**\r\n   * cancel event name used by the template\r\n   *\r\n   * @default 'cancel'\r\n   */\r\n    cancel?: string\r\n    /**\r\n   * confirm event name used by the template\r\n   *\r\n   * @default 'confirm'\r\n   */\r\n    confirm?: string\r\n  }\r\n  /**\r\n   * whether to automatically handle components based on visible and animation\r\n   *\r\n   * @default true\r\n   */\r\n  automatic?: boolean\r\n}\r\n\r\nexport interface OverlayMeta {\r\n  /** the notification cancel, modify visible, and destroy it after the animation ends */\r\n  cancel: Function\r\n  /** the notification confirm, modify visible, and destroy it after the animation ends */\r\n  confirm: Function\r\n  /** destroy the current instance (immediately) */\r\n  vanish: Function\r\n  /** visible control popup display and hide */\r\n  visible: Ref<boolean>\r\n  /** use in template */\r\n  isTemplate?: boolean\r\n}\r\n\r\n/**\r\n * get overlay layer meta information\r\n * @function cancel  the notification cancel, modify visible, and destroy it after the animation ends\r\n * @function confirm the notification confirm, modify visible, and destroy it after the animation ends\r\n * @function vanish destroy the current instance (immediately)\r\n * @field visible control popup display and hide\r\n * @returns\r\n */\r\nexport function useOverlayMeta(options: OverlayOptions = {}) {\r\n  const { animation = 0, immediate = true, model = 'visible', automatic = true } = options\r\n  const meta = inject(OverlayMetaKey, useTemplateMeta(model, options))\r\n\r\n  // The component directly obtains the default value\r\n  // vanish will have no effect, and no watch will be performed.\r\n  if (!meta.isTemplate && automatic) {\r\n    watch(meta.visible, async () => {\r\n      if (meta.visible.value)\r\n        return undefined\r\n      if (animation > 0)\r\n        await delay(animation)\r\n      meta.vanish?.()\r\n    })\r\n  }\r\n\r\n  if (immediate)\r\n    onMounted(() => (meta.visible.value = true))\r\n\r\n  provide(OverlayMetaKey, null)\r\n  return meta\r\n}\r\n\r\nexport function useTemplateMeta(model: string, options: OverlayOptions = {}) {\r\n  const instance = getCurrentInstance()\r\n  const events = options.event || {}\r\n\r\n  const visible = instance ? useVModel(instance.props, model) as Ref<boolean> : ref(false)\r\n\r\n  const cancel = (value?: any) => {\r\n    visible.value = false\r\n    instance?.emit(events.cancel || 'cancel', value)\r\n  }\r\n  const confirm = (value?: any) => {\r\n    visible.value = false\r\n    instance?.emit(events.confirm || 'confirm', value)\r\n  }\r\n  return {\r\n    cancel,\r\n    confirm,\r\n    vanish: noop,\r\n    visible,\r\n    isTemplate: true,\r\n  }\r\n}\r\n", "export const UnifiedOverlayProviderID = 'unified-overlay'\r\n\r\nexport function createGlobalNode(id = '', root: HTMLElement = document.body) {\r\n  const el = document.createElement('div')\r\n\r\n  if (id)\r\n    el.id = id\r\n\r\n  root.appendChild(el)\r\n\r\n  return el\r\n}\r\n", "import { UnifiedOverlayProviderID } from './global'\r\n\r\nexport function noop() {}\r\n\r\nexport function allowed() {\r\n  throw new Error('overlay - Error: It is not allowed to call confirm and cancel externally immediately, please wait for the component to render')\r\n}\r\n\r\nexport function delay(milliseconds: number) {\r\n  return new Promise(resolve => setTimeout(resolve, milliseconds))\r\n}\r\n\r\nexport function varName(id = UnifiedOverlayProviderID, auto = true) {\r\n  if (auto)\r\n    return `${id}--${varName.index++}`\r\n\r\n  return id\r\n}\r\n\r\nvarName.index = 1\r\n", "import { allowed } from './tools'\r\n\r\nexport type ImperativePromiser<T = void> = Promiser<{ confirm: Function; cancel: Function }, T>\r\nexport type ImperativePromise<T = void> = ImperativePromiser<T>['promise']\r\n\r\nexport interface Promiser<P = object, T = void> {\r\n  promise: Promise<T> & P\r\n  resolve: Function\r\n  reject: Function\r\n}\r\n\r\nexport function createPromiser<P, T = void>(): Promiser<P, T> {\r\n  let resolve!: Function\r\n  let reject!: Function\r\n  const promise = new Promise<any>((_resolve, _reject) => {\r\n    resolve = _resolve\r\n    reject = _reject\r\n  }) as unknown as any\r\n  return { promise, reject, resolve }\r\n}\r\n\r\nexport function createImperativePromiser<T = void>() {\r\n  const promiser = createPromiser<{ confirm: Function; cancel: Function }, T>()\r\n  promiser.promise.confirm = allowed\r\n  promiser.promise.cancel = allowed\r\n  return promiser as ImperativePromiser<T>\r\n}\r\n", "import type { Ref } from 'vue-demi'\r\nimport type { Emitter } from 'mitt'\r\nimport { OverEvents } from '../internal'\r\nimport type { ImperativePromiser } from '../utils'\r\n\r\nexport interface VisiblePromiseOptions {\r\n  promiser?: ImperativePromiser\r\n  vanish?: Function\r\n  events?: Emitter<any>\r\n}\r\n\r\nexport function useVisibleScripts(visible: Ref<boolean>, options: VisiblePromiseOptions) {\r\n  function cancel(value?: any) {\r\n    options.promiser?.reject(value)\r\n    options.events?.emit(OverEvents.Cancel, value)\r\n    visible.value = false\r\n  }\r\n  function confirm(value?: any) {\r\n    options.promiser?.resolve(value)\r\n    options.events?.emit(OverEvents.Confirm, value)\r\n    visible.value = false\r\n  }\r\n  function vanish() {\r\n    options.vanish?.()\r\n    options.promiser?.reject()\r\n  }\r\n\r\n  if (options.promiser) {\r\n    options.promiser.promise.confirm = confirm\r\n    options.promiser.promise.cancel = cancel\r\n  }\r\n\r\n  return { visible, confirm, cancel, vanish }\r\n}\r\n", "import type { Component } from 'vue-demi'\r\nimport { Teleport, h, nextTick, provide, reactive, ref } from 'vue-demi'\r\n\r\nimport mitt from 'mitt'\r\n\r\nimport type { MountOptions } from '../helper'\r\nimport { defineProviderComponent } from '../helper'\r\nimport { createImperativePromiser, varName } from '../utils'\r\nimport { OverlayMetaKey } from '../internal'\r\nimport type { ImperativeOverlay } from '../transform'\r\nimport type { VisiblePromiseOptions } from './visible'\r\nimport { useVisibleScripts } from './visible'\r\n\r\nexport type InjectionHolder<Props, Resolved> = [ImperativeOverlay<Props, Resolved>, Component]\r\n\r\nexport function useInjectHolder<Props, Resolved = void>(\r\n  component: Component,\r\n  options: Omit<MountOptions, 'appContext'> = {},\r\n): InjectionHolder<Props, Resolved> {\r\n  const { callback, scripts, props, refresh } = useRefreshMetadata()\r\n  const name = varName(options.id, options.autoIncrement)\r\n\r\n  function render() {\r\n    return h(Teleport,\r\n      { to: options.root || document.body, disabled: !!(options.root === false) },\r\n      [\r\n        h('div', { id: name }, [h(component, props.value)]),\r\n      ],\r\n    )\r\n  }\r\n\r\n  const holder = defineProviderComponent(component, {\r\n    render: false,\r\n    setup() {\r\n      provide(OverlayMetaKey, scripts)\r\n      return () => refresh.value ? render() : null\r\n    },\r\n  })\r\n\r\n  return [callback as any, holder]\r\n}\r\n\r\nexport function useRefreshMetadata() {\r\n  const visible = ref(false)\r\n  const refresh = ref(false)\r\n  const events = mitt()\r\n  const props = ref<any>()\r\n  const options = reactive<VisiblePromiseOptions>({\r\n    events,\r\n    vanish,\r\n  })\r\n  const scripts = useVisibleScripts(visible, options)\r\n\r\n  function vanish() {\r\n    refresh.value = false\r\n    props.value = {}\r\n    events.off('*')\r\n  }\r\n\r\n  async function callback(_props: any) {\r\n    props.value = _props\r\n    refresh.value = true\r\n    await nextTick()\r\n    visible.value = true\r\n    const promiser = createImperativePromiser()\r\n    Object.assign(options, { promiser })\r\n    return promiser.promise\r\n  }\r\n\r\n  return { callback, scripts, props, refresh }\r\n}\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Component } from 'vue-demi'\r\nimport { createApp, createVNode, defineComponent, h, render } from 'vue-demi'\r\n\r\nimport { pascalCase } from 'pascal-case'\r\nimport { context } from '../internal'\r\nimport { createGlobalNode, varName } from '../utils'\r\nimport { defineProviderComponent } from './define'\r\nimport type { MountOptions } from './interface'\r\n\r\nexport interface RenderChildOptions extends MountOptions {\r\n  setup?: () => void\r\n}\r\n\r\nexport function renderVNode(\r\n  component: Component,\r\n  props?: Record<string, any>,\r\n  options: RenderChildOptions = {},\r\n) {\r\n  // There is no need to call document.body.removeChild(container.firstElementChild) here\r\n  // Because calling render(null, container) does the work for us\r\n  const name = varName(options.id, options.autoIncrement)\r\n\r\n  function vanish() {\r\n    render(null, container)\r\n    container.remove()\r\n  }\r\n\r\n  const Provider = defineProviderComponent(component, {\r\n    name: pascalCase(name),\r\n    setup: options.setup,\r\n    props,\r\n  })\r\n\r\n  const vnode = createVNode(Provider)\r\n  const container = createGlobalNode(name, options.root || document.body)\r\n\r\n  vnode.appContext = options.appContext || context.appContext\r\n\r\n  render(vnode, container)\r\n\r\n  return { vanish }\r\n}\r\n\r\nexport function renderChildApp(\r\n  component: Component,\r\n  props?: Record<string, any>,\r\n  options: RenderChildOptions = {}) {\r\n  const name = varName(options.id, options.autoIncrement)\r\n\r\n  function vanish() {\r\n    app.unmount()\r\n    container.remove()\r\n  }\r\n\r\n  const Provider = defineComponent({\r\n    name: pascalCase(name),\r\n    setup() {\r\n      options.setup?.()\r\n    },\r\n    render() {\r\n      return h(component as any, props)\r\n    },\r\n  })\r\n\r\n  const app = createApp(Provider)\r\n\r\n  const parent = options.appContext?.app || context.appContext?.app\r\n  if (parent) {\r\n    app.config.globalProperties = parent.config.globalProperties\r\n    const { reload, ...appContext } = parent._context as any\r\n    Object.assign(app._context, appContext)\r\n  }\r\n\r\n  const container = createGlobalNode(name, options.root || document.body)\r\n\r\n  app.mount(container)\r\n\r\n  return { vanish }\r\n}\r\n", "import type { Component, RenderFunction, SetupContext } from 'vue-demi'\r\nimport { defineComponent, h } from 'vue-demi'\r\n\r\nexport interface ComponentOptions {\r\n  name?: string\r\n  props?: any\r\n  setup?: (props: any, context: SetupContext) => RenderFunction | void | any\r\n  render?: Function | false\r\n}\r\nexport function defineProviderComponent(component: Component, options: ComponentOptions) {\r\n  function defaultRender() {\r\n    return h(component, options.props)\r\n  }\r\n  const Provider = defineComponent({\r\n    name: options.name,\r\n    setup: options.setup,\r\n    render: options.render === false\r\n      ? undefined\r\n      : (options.render || defaultRender),\r\n  })\r\n  return Provider\r\n}\r\n", "import type { Component, ExtractPropTypes } from 'vue-demi'\r\nimport { provide, ref } from 'vue-demi'\r\n\r\nimport { renderChildApp } from '../helper'\r\nimport type { MountOptions } from '../helper'\r\nimport { OverlayMetaKey } from '../internal'\r\nimport type { ImperativePromise } from '../utils'\r\nimport { createImperativePromiser, noop } from '../utils'\r\n\r\nimport { useVisibleScripts } from '../hooks'\r\n\r\nexport interface ImperativeOverlay<Props, Resolved> {\r\n  (props?: ExtractPropTypes<Props>, options?: MountOptions): ImperativePromise<Resolved>\r\n}\r\n\r\nexport interface RenderOptions<Props> extends MountOptions {\r\n  props?: ExtractPropTypes<Props>\r\n}\r\n\r\n/**\r\n * Create imperative overlay\r\n * @param component Component\r\n */\r\nexport function createOverlay<Props, Resolved = void>(component: Component): ImperativeOverlay<Props, Resolved> {\r\n  function executor(props: any, promiser: any, options?: any) {\r\n    const caches = { vanish: noop }\r\n    function setup() {\r\n      const visible = ref(false)\r\n      const scripts = useVisibleScripts(visible, Object.assign(caches, { promiser }))\r\n      provide(OverlayMetaKey, scripts)\r\n    }\r\n    caches.vanish = renderChildApp(component, props, { ...options, setup }).vanish\r\n  }\r\n\r\n  function caller(props: any, options?: any) {\r\n    const promiser = createImperativePromiser()\r\n    executor(props, promiser, options)\r\n    return promiser.promise as unknown as ImperativePromise<Resolved>\r\n  }\r\n\r\n  return caller\r\n}\r\n\r\n/**\r\n * Execute overlay component\r\n * @param component Component\r\n * @param options mount options and props\r\n */\r\nexport function renderOverlay<Props = {}, Resolved = void>(\r\n  component: Component,\r\n  options: RenderOptions<Props> = {},\r\n) {\r\n  return createOverlay<Props, Resolved>(component)(options.props, options)\r\n}\r\n", "import type { Component } from 'vue-demi'\r\nimport { defineComponent, getCurrentInstance } from 'vue-demi'\r\nimport { context } from '../internal'\r\n\r\nexport const UnifiedOverlayProvider = defineComponent({\r\n  setup(_, { slots }) {\r\n    const { appContext } = getCurrentInstance()!\r\n    context.appContext = appContext\r\n    return () => slots.default?.()\r\n  },\r\n}) as Component\r\n"],
  "mappings": "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",
  "names": []
}
