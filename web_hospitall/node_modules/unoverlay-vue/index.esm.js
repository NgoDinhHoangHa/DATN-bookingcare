"use strict";

// src/internal/index.ts
var context = {
  appContext: null
};
var OverlayMetaKey = Symbol("__imperative_overlay_key");

// src/hooks/meta.ts
import { getCurrentInstance, inject, onMounted, provide, ref, watch } from "vue-demi";
import { useVModel } from "@vueuse/core";

// src/utils/global.ts
var UnifiedOverlayProviderID = "unified-overlay";
function createGlobalNode(id = "", root = document.body) {
  const el = document.createElement("div");
  if (id)
    el.id = id;
  root.appendChild(el);
  return el;
}

// src/utils/tools.ts
function noop() {
}
function allowed() {
  throw new Error("overlay - Error: It is not allowed to call confirm and cancel externally immediately, please wait for the component to render");
}
function delay(milliseconds) {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
}
function varName(id = UnifiedOverlayProviderID, auto = true) {
  if (auto)
    return `${id}--${varName.index++}`;
  return id;
}
varName.index = 1;

// src/utils/promise.ts
function createPromiser() {
  let resolve;
  let reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  return { promise, reject, resolve };
}
function createImperativePromiser() {
  const promiser = createPromiser();
  promiser.promise.confirm = allowed;
  promiser.promise.cancel = allowed;
  return promiser;
}

// src/hooks/meta.ts
function useOverlayMeta(options = {}) {
  const { animation = 0, immediate = true, model = "visible", automatic = true } = options;
  const meta = inject(OverlayMetaKey, useTemplateMeta(model, options));
  if (!meta.isTemplate && automatic) {
    watch(meta.visible, async () => {
      var _a;
      if (meta.visible.value)
        return void 0;
      if (animation > 0)
        await delay(animation);
      (_a = meta.vanish) == null ? void 0 : _a.call(meta);
    });
  }
  if (immediate)
    onMounted(() => meta.visible.value = true);
  provide(OverlayMetaKey, null);
  return meta;
}
function useTemplateMeta(model, options = {}) {
  const instance = getCurrentInstance();
  const events = options.event || {};
  const visible = instance ? useVModel(instance.props, model) : ref(false);
  const cancel = (value) => {
    visible.value = false;
    instance == null ? void 0 : instance.emit(events.cancel || "cancel", value);
  };
  const confirm = (value) => {
    visible.value = false;
    instance == null ? void 0 : instance.emit(events.confirm || "confirm", value);
  };
  return {
    cancel,
    confirm,
    vanish: noop,
    visible,
    isTemplate: true
  };
}

// src/hooks/visible.ts
function useVisibleScripts(visible, options) {
  function cancel(value) {
    var _a, _b;
    (_a = options.promiser) == null ? void 0 : _a.reject(value);
    (_b = options.events) == null ? void 0 : _b.emit("cancel" /* Cancel */, value);
    visible.value = false;
  }
  function confirm(value) {
    var _a, _b;
    (_a = options.promiser) == null ? void 0 : _a.resolve(value);
    (_b = options.events) == null ? void 0 : _b.emit("confirm" /* Confirm */, value);
    visible.value = false;
  }
  function vanish() {
    var _a, _b;
    (_a = options.vanish) == null ? void 0 : _a.call(options);
    (_b = options.promiser) == null ? void 0 : _b.reject();
  }
  if (options.promiser) {
    options.promiser.promise.confirm = confirm;
    options.promiser.promise.cancel = cancel;
  }
  return { visible, confirm, cancel, vanish };
}

// src/hooks/holder.ts
import { Teleport, h as h3, nextTick, provide as provide2, reactive, ref as ref2 } from "vue-demi";
import mitt from "mitt";

// src/helper/render.ts
import { createApp, createVNode, defineComponent as defineComponent2, h as h2, render } from "vue-demi";
import { pascalCase } from "pascal-case";

// src/helper/define.ts
import { defineComponent, h } from "vue-demi";
function defineProviderComponent(component, options) {
  function defaultRender() {
    return h(component, options.props);
  }
  const Provider = defineComponent({
    name: options.name,
    setup: options.setup,
    render: options.render === false ? void 0 : options.render || defaultRender
  });
  return Provider;
}

// src/helper/render.ts
function renderChildApp(component, props, options = {}) {
  var _a, _b;
  const name = varName(options.id, options.autoIncrement);
  function vanish() {
    app.unmount();
    container.remove();
  }
  const Provider = defineComponent2({
    name: pascalCase(name),
    setup() {
      var _a2;
      (_a2 = options.setup) == null ? void 0 : _a2.call(options);
    },
    render() {
      return h2(component, props);
    }
  });
  const app = createApp(Provider);
  const parent = ((_a = options.appContext) == null ? void 0 : _a.app) || ((_b = context.appContext) == null ? void 0 : _b.app);
  if (parent) {
    app.config.globalProperties = parent.config.globalProperties;
    const { reload, ...appContext } = parent._context;
    Object.assign(app._context, appContext);
  }
  const container = createGlobalNode(name, options.root || document.body);
  app.mount(container);
  return { vanish };
}

// src/hooks/holder.ts
function useInjectHolder(component, options = {}) {
  const { callback, scripts, props, refresh } = useRefreshMetadata();
  const name = varName(options.id, options.autoIncrement);
  function render2() {
    return h3(Teleport, { to: options.root || document.body, disabled: !!(options.root === false) }, [
      h3("div", { id: name }, [h3(component, props.value)])
    ]);
  }
  const holder = defineProviderComponent(component, {
    render: false,
    setup() {
      provide2(OverlayMetaKey, scripts);
      return () => refresh.value ? render2() : null;
    }
  });
  return [callback, holder];
}
function useRefreshMetadata() {
  const visible = ref2(false);
  const refresh = ref2(false);
  const events = mitt();
  const props = ref2();
  const options = reactive({
    events,
    vanish
  });
  const scripts = useVisibleScripts(visible, options);
  function vanish() {
    refresh.value = false;
    props.value = {};
    events.off("*");
  }
  async function callback(_props) {
    props.value = _props;
    refresh.value = true;
    await nextTick();
    visible.value = true;
    const promiser = createImperativePromiser();
    Object.assign(options, { promiser });
    return promiser.promise;
  }
  return { callback, scripts, props, refresh };
}

// src/transform/index.ts
import { provide as provide3, ref as ref3 } from "vue-demi";
function createOverlay(component) {
  function executor(props, promiser, options) {
    const caches = { vanish: noop };
    function setup() {
      const visible = ref3(false);
      const scripts = useVisibleScripts(visible, Object.assign(caches, { promiser }));
      provide3(OverlayMetaKey, scripts);
    }
    caches.vanish = renderChildApp(component, props, { ...options, setup }).vanish;
  }
  function caller(props, options) {
    const promiser = createImperativePromiser();
    executor(props, promiser, options);
    return promiser.promise;
  }
  return caller;
}
function renderOverlay(component, options = {}) {
  return createOverlay(component)(options.props, options);
}

// src/components/index.ts
import { defineComponent as defineComponent3, getCurrentInstance as getCurrentInstance2 } from "vue-demi";
var UnifiedOverlayProvider = defineComponent3({
  setup(_, { slots }) {
    const { appContext } = getCurrentInstance2();
    context.appContext = appContext;
    return () => {
      var _a;
      return (_a = slots.default) == null ? void 0 : _a.call(slots);
    };
  }
});

// src/index.ts
var install = (app) => {
  context.appContext = app._context;
};
var unoverlay = { install };
var src_default = unoverlay;
export {
  UnifiedOverlayProvider,
  createOverlay,
  src_default as default,
  install,
  renderOverlay,
  useInjectHolder,
  useOverlayMeta
};
//# sourceMappingURL=index.esm.js.map
